// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: janction/videoRendering/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Coin } from "../../../cosmos/base/v1beta1/coin";

export const protobufPackage = "janction.videoRendering.v1";

/** Params defines the parameters of the module. */
export interface Params {
  minWorkerStaking?: Coin | undefined;
  maxWorkersPerThread: Long;
  minValidators: Long;
}

/** GenesisState is the state that must be provided at genesis. */
export interface GenesisState {
  /** params defines all the parameters of the module. */
  params?:
    | Params
    | undefined;
  /** Video Rendering Task index */
  videoRenderingTaskInfo?:
    | VideoRenderingTaskInfo
    | undefined;
  /** List of Video Rendering tasks */
  videoRenderingTaskList: IndexedVideoRenderingTask[];
  /** List of Workers */
  workers: Worker[];
}

export interface Worker {
  address: string;
  reputation?: Worker_Reputation | undefined;
  enabled: boolean;
  currentTaskId: string;
  currentThreadIndex: number;
  publicIp: string;
  ipfsId: string;
}

export interface Worker_Reputation {
  staked?: Coin | undefined;
  points: Long;
  validations: number;
  solutions: number;
  winnings?: Coin | undefined;
}

/**
 * Video Rendering Task
 * @cid the IPFS CID submitted by a task requester
 */
export interface VideoRenderingTask {
  taskId: string;
  requester: string;
  cid: string;
  startFrame: number;
  endFrame: number;
  threadAmount: number;
  completed: boolean;
  reward?: Coin | undefined;
  threads: VideoRenderingThread[];
}

/**
 * A Video Rendering Thread is the smallest unit of work for a Task.
 * Workers will try to complete a thread as soon as possible to submit first a solution
 */
export interface VideoRenderingThread {
  threadId: string;
  taskId: string;
  startFrame: number;
  endFrame: number;
  completed: boolean;
  workers: string[];
  solution?: VideoRenderingThread_Solution | undefined;
  validations: VideoRenderingThread_Validation[];
}

export interface VideoRenderingThread_Solution {
  proposedBy: string;
  hashes: string[];
  files: string;
}

export interface VideoRenderingThread_Validation {
  validator: string;
  amountFiles: Long;
  valid: boolean;
  isReverse: boolean;
}

/** Stores information about the Video Rendering  task */
export interface VideoRenderingTaskInfo {
  nextId: Long;
}

/** Stores the Video Rendering Task with the index */
export interface IndexedVideoRenderingTask {
  index: string;
  videoRenderingTask?: VideoRenderingTask | undefined;
}

export interface VideoRenderingLogs {
  threadId: string;
  logs: VideoRenderingLogs_VideoRenderingLog[];
}

export interface VideoRenderingLogs_VideoRenderingLog {
  log: string;
  timestamp: Long;
  severity: VideoRenderingLogs_VideoRenderingLog_SEVERITY;
}

export enum VideoRenderingLogs_VideoRenderingLog_SEVERITY {
  INFO = 0,
  SUCCESS = 1,
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function videoRenderingLogs_VideoRenderingLog_SEVERITYFromJSON(
  object: any,
): VideoRenderingLogs_VideoRenderingLog_SEVERITY {
  switch (object) {
    case 0:
    case "INFO":
      return VideoRenderingLogs_VideoRenderingLog_SEVERITY.INFO;
    case 1:
    case "SUCCESS":
      return VideoRenderingLogs_VideoRenderingLog_SEVERITY.SUCCESS;
    case 2:
    case "ERROR":
      return VideoRenderingLogs_VideoRenderingLog_SEVERITY.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VideoRenderingLogs_VideoRenderingLog_SEVERITY.UNRECOGNIZED;
  }
}

export function videoRenderingLogs_VideoRenderingLog_SEVERITYToJSON(
  object: VideoRenderingLogs_VideoRenderingLog_SEVERITY,
): string {
  switch (object) {
    case VideoRenderingLogs_VideoRenderingLog_SEVERITY.INFO:
      return "INFO";
    case VideoRenderingLogs_VideoRenderingLog_SEVERITY.SUCCESS:
      return "SUCCESS";
    case VideoRenderingLogs_VideoRenderingLog_SEVERITY.ERROR:
      return "ERROR";
    case VideoRenderingLogs_VideoRenderingLog_SEVERITY.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseParams(): Params {
  return { minWorkerStaking: undefined, maxWorkersPerThread: Long.UZERO, minValidators: Long.UZERO };
}

export const Params: MessageFns<Params> = {
  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minWorkerStaking !== undefined) {
      Coin.encode(message.minWorkerStaking, writer.uint32(10).fork()).join();
    }
    if (!message.maxWorkersPerThread.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.maxWorkersPerThread.toString());
    }
    if (!message.minValidators.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.minValidators.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minWorkerStaking = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxWorkersPerThread = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minValidators = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      minWorkerStaking: isSet(object.minWorkerStaking) ? Coin.fromJSON(object.minWorkerStaking) : undefined,
      maxWorkersPerThread: isSet(object.maxWorkersPerThread) ? Long.fromValue(object.maxWorkersPerThread) : Long.UZERO,
      minValidators: isSet(object.minValidators) ? Long.fromValue(object.minValidators) : Long.UZERO,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.minWorkerStaking !== undefined) {
      obj.minWorkerStaking = Coin.toJSON(message.minWorkerStaking);
    }
    if (!message.maxWorkersPerThread.equals(Long.UZERO)) {
      obj.maxWorkersPerThread = (message.maxWorkersPerThread || Long.UZERO).toString();
    }
    if (!message.minValidators.equals(Long.UZERO)) {
      obj.minValidators = (message.minValidators || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Params>, I>>(base?: I): Params {
    return Params.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {
    const message = createBaseParams();
    message.minWorkerStaking = (object.minWorkerStaking !== undefined && object.minWorkerStaking !== null)
      ? Coin.fromPartial(object.minWorkerStaking)
      : undefined;
    message.maxWorkersPerThread = (object.maxWorkersPerThread !== undefined && object.maxWorkersPerThread !== null)
      ? Long.fromValue(object.maxWorkersPerThread)
      : Long.UZERO;
    message.minValidators = (object.minValidators !== undefined && object.minValidators !== null)
      ? Long.fromValue(object.minValidators)
      : Long.UZERO;
    return message;
  },
};

function createBaseGenesisState(): GenesisState {
  return { params: undefined, videoRenderingTaskInfo: undefined, videoRenderingTaskList: [], workers: [] };
}

export const GenesisState: MessageFns<GenesisState> = {
  encode(message: GenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.videoRenderingTaskInfo !== undefined) {
      VideoRenderingTaskInfo.encode(message.videoRenderingTaskInfo, writer.uint32(26).fork()).join();
    }
    for (const v of message.videoRenderingTaskList) {
      IndexedVideoRenderingTask.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.workers) {
      Worker.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.videoRenderingTaskInfo = VideoRenderingTaskInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.videoRenderingTaskList.push(IndexedVideoRenderingTask.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workers.push(Worker.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
      videoRenderingTaskInfo: isSet(object.videoRenderingTaskInfo)
        ? VideoRenderingTaskInfo.fromJSON(object.videoRenderingTaskInfo)
        : undefined,
      videoRenderingTaskList: globalThis.Array.isArray(object?.videoRenderingTaskList)
        ? object.videoRenderingTaskList.map((e: any) => IndexedVideoRenderingTask.fromJSON(e))
        : [],
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => Worker.fromJSON(e)) : [],
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    if (message.videoRenderingTaskInfo !== undefined) {
      obj.videoRenderingTaskInfo = VideoRenderingTaskInfo.toJSON(message.videoRenderingTaskInfo);
    }
    if (message.videoRenderingTaskList?.length) {
      obj.videoRenderingTaskList = message.videoRenderingTaskList.map((e) => IndexedVideoRenderingTask.toJSON(e));
    }
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => Worker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenesisState>, I>>(base?: I): GenesisState {
    return GenesisState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenesisState>, I>>(object: I): GenesisState {
    const message = createBaseGenesisState();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    message.videoRenderingTaskInfo =
      (object.videoRenderingTaskInfo !== undefined && object.videoRenderingTaskInfo !== null)
        ? VideoRenderingTaskInfo.fromPartial(object.videoRenderingTaskInfo)
        : undefined;
    message.videoRenderingTaskList =
      object.videoRenderingTaskList?.map((e) => IndexedVideoRenderingTask.fromPartial(e)) || [];
    message.workers = object.workers?.map((e) => Worker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorker(): Worker {
  return {
    address: "",
    reputation: undefined,
    enabled: false,
    currentTaskId: "",
    currentThreadIndex: 0,
    publicIp: "",
    ipfsId: "",
  };
}

export const Worker: MessageFns<Worker> = {
  encode(message: Worker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.reputation !== undefined) {
      Worker_Reputation.encode(message.reputation, writer.uint32(26).fork()).join();
    }
    if (message.enabled !== false) {
      writer.uint32(32).bool(message.enabled);
    }
    if (message.currentTaskId !== "") {
      writer.uint32(42).string(message.currentTaskId);
    }
    if (message.currentThreadIndex !== 0) {
      writer.uint32(48).uint32(message.currentThreadIndex);
    }
    if (message.publicIp !== "") {
      writer.uint32(58).string(message.publicIp);
    }
    if (message.ipfsId !== "") {
      writer.uint32(66).string(message.ipfsId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reputation = Worker_Reputation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currentTaskId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.currentThreadIndex = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.publicIp = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ipfsId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Worker {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      reputation: isSet(object.reputation) ? Worker_Reputation.fromJSON(object.reputation) : undefined,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      currentTaskId: isSet(object.currentTaskId) ? globalThis.String(object.currentTaskId) : "",
      currentThreadIndex: isSet(object.currentThreadIndex) ? globalThis.Number(object.currentThreadIndex) : 0,
      publicIp: isSet(object.publicIp) ? globalThis.String(object.publicIp) : "",
      ipfsId: isSet(object.ipfsId) ? globalThis.String(object.ipfsId) : "",
    };
  },

  toJSON(message: Worker): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.reputation !== undefined) {
      obj.reputation = Worker_Reputation.toJSON(message.reputation);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.currentTaskId !== "") {
      obj.currentTaskId = message.currentTaskId;
    }
    if (message.currentThreadIndex !== 0) {
      obj.currentThreadIndex = Math.round(message.currentThreadIndex);
    }
    if (message.publicIp !== "") {
      obj.publicIp = message.publicIp;
    }
    if (message.ipfsId !== "") {
      obj.ipfsId = message.ipfsId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Worker>, I>>(base?: I): Worker {
    return Worker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Worker>, I>>(object: I): Worker {
    const message = createBaseWorker();
    message.address = object.address ?? "";
    message.reputation = (object.reputation !== undefined && object.reputation !== null)
      ? Worker_Reputation.fromPartial(object.reputation)
      : undefined;
    message.enabled = object.enabled ?? false;
    message.currentTaskId = object.currentTaskId ?? "";
    message.currentThreadIndex = object.currentThreadIndex ?? 0;
    message.publicIp = object.publicIp ?? "";
    message.ipfsId = object.ipfsId ?? "";
    return message;
  },
};

function createBaseWorker_Reputation(): Worker_Reputation {
  return { staked: undefined, points: Long.ZERO, validations: 0, solutions: 0, winnings: undefined };
}

export const Worker_Reputation: MessageFns<Worker_Reputation> = {
  encode(message: Worker_Reputation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.staked !== undefined) {
      Coin.encode(message.staked, writer.uint32(10).fork()).join();
    }
    if (!message.points.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.points.toString());
    }
    if (message.validations !== 0) {
      writer.uint32(24).uint32(message.validations);
    }
    if (message.solutions !== 0) {
      writer.uint32(32).uint32(message.solutions);
    }
    if (message.winnings !== undefined) {
      Coin.encode(message.winnings, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worker_Reputation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorker_Reputation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.staked = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.points = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.validations = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.solutions = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.winnings = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Worker_Reputation {
    return {
      staked: isSet(object.staked) ? Coin.fromJSON(object.staked) : undefined,
      points: isSet(object.points) ? Long.fromValue(object.points) : Long.ZERO,
      validations: isSet(object.validations) ? globalThis.Number(object.validations) : 0,
      solutions: isSet(object.solutions) ? globalThis.Number(object.solutions) : 0,
      winnings: isSet(object.winnings) ? Coin.fromJSON(object.winnings) : undefined,
    };
  },

  toJSON(message: Worker_Reputation): unknown {
    const obj: any = {};
    if (message.staked !== undefined) {
      obj.staked = Coin.toJSON(message.staked);
    }
    if (!message.points.equals(Long.ZERO)) {
      obj.points = (message.points || Long.ZERO).toString();
    }
    if (message.validations !== 0) {
      obj.validations = Math.round(message.validations);
    }
    if (message.solutions !== 0) {
      obj.solutions = Math.round(message.solutions);
    }
    if (message.winnings !== undefined) {
      obj.winnings = Coin.toJSON(message.winnings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Worker_Reputation>, I>>(base?: I): Worker_Reputation {
    return Worker_Reputation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Worker_Reputation>, I>>(object: I): Worker_Reputation {
    const message = createBaseWorker_Reputation();
    message.staked = (object.staked !== undefined && object.staked !== null)
      ? Coin.fromPartial(object.staked)
      : undefined;
    message.points = (object.points !== undefined && object.points !== null)
      ? Long.fromValue(object.points)
      : Long.ZERO;
    message.validations = object.validations ?? 0;
    message.solutions = object.solutions ?? 0;
    message.winnings = (object.winnings !== undefined && object.winnings !== null)
      ? Coin.fromPartial(object.winnings)
      : undefined;
    return message;
  },
};

function createBaseVideoRenderingTask(): VideoRenderingTask {
  return {
    taskId: "",
    requester: "",
    cid: "",
    startFrame: 0,
    endFrame: 0,
    threadAmount: 0,
    completed: false,
    reward: undefined,
    threads: [],
  };
}

export const VideoRenderingTask: MessageFns<VideoRenderingTask> = {
  encode(message: VideoRenderingTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.requester !== "") {
      writer.uint32(18).string(message.requester);
    }
    if (message.cid !== "") {
      writer.uint32(26).string(message.cid);
    }
    if (message.startFrame !== 0) {
      writer.uint32(32).uint32(message.startFrame);
    }
    if (message.endFrame !== 0) {
      writer.uint32(40).uint32(message.endFrame);
    }
    if (message.threadAmount !== 0) {
      writer.uint32(48).uint32(message.threadAmount);
    }
    if (message.completed !== false) {
      writer.uint32(56).bool(message.completed);
    }
    if (message.reward !== undefined) {
      Coin.encode(message.reward, writer.uint32(66).fork()).join();
    }
    for (const v of message.threads) {
      VideoRenderingThread.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoRenderingTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoRenderingTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requester = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startFrame = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.endFrame = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.threadAmount = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reward = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.threads.push(VideoRenderingThread.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoRenderingTask {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      requester: isSet(object.requester) ? globalThis.String(object.requester) : "",
      cid: isSet(object.cid) ? globalThis.String(object.cid) : "",
      startFrame: isSet(object.startFrame) ? globalThis.Number(object.startFrame) : 0,
      endFrame: isSet(object.endFrame) ? globalThis.Number(object.endFrame) : 0,
      threadAmount: isSet(object.threadAmount) ? globalThis.Number(object.threadAmount) : 0,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
      reward: isSet(object.reward) ? Coin.fromJSON(object.reward) : undefined,
      threads: globalThis.Array.isArray(object?.threads)
        ? object.threads.map((e: any) => VideoRenderingThread.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoRenderingTask): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.requester !== "") {
      obj.requester = message.requester;
    }
    if (message.cid !== "") {
      obj.cid = message.cid;
    }
    if (message.startFrame !== 0) {
      obj.startFrame = Math.round(message.startFrame);
    }
    if (message.endFrame !== 0) {
      obj.endFrame = Math.round(message.endFrame);
    }
    if (message.threadAmount !== 0) {
      obj.threadAmount = Math.round(message.threadAmount);
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    if (message.reward !== undefined) {
      obj.reward = Coin.toJSON(message.reward);
    }
    if (message.threads?.length) {
      obj.threads = message.threads.map((e) => VideoRenderingThread.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoRenderingTask>, I>>(base?: I): VideoRenderingTask {
    return VideoRenderingTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoRenderingTask>, I>>(object: I): VideoRenderingTask {
    const message = createBaseVideoRenderingTask();
    message.taskId = object.taskId ?? "";
    message.requester = object.requester ?? "";
    message.cid = object.cid ?? "";
    message.startFrame = object.startFrame ?? 0;
    message.endFrame = object.endFrame ?? 0;
    message.threadAmount = object.threadAmount ?? 0;
    message.completed = object.completed ?? false;
    message.reward = (object.reward !== undefined && object.reward !== null)
      ? Coin.fromPartial(object.reward)
      : undefined;
    message.threads = object.threads?.map((e) => VideoRenderingThread.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoRenderingThread(): VideoRenderingThread {
  return {
    threadId: "",
    taskId: "",
    startFrame: 0,
    endFrame: 0,
    completed: false,
    workers: [],
    solution: undefined,
    validations: [],
  };
}

export const VideoRenderingThread: MessageFns<VideoRenderingThread> = {
  encode(message: VideoRenderingThread, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threadId !== "") {
      writer.uint32(10).string(message.threadId);
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    if (message.startFrame !== 0) {
      writer.uint32(24).uint32(message.startFrame);
    }
    if (message.endFrame !== 0) {
      writer.uint32(32).uint32(message.endFrame);
    }
    if (message.completed !== false) {
      writer.uint32(40).bool(message.completed);
    }
    for (const v of message.workers) {
      writer.uint32(50).string(v!);
    }
    if (message.solution !== undefined) {
      VideoRenderingThread_Solution.encode(message.solution, writer.uint32(58).fork()).join();
    }
    for (const v of message.validations) {
      VideoRenderingThread_Validation.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoRenderingThread {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoRenderingThread();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.threadId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startFrame = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.endFrame = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workers.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.solution = VideoRenderingThread_Solution.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.validations.push(VideoRenderingThread_Validation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoRenderingThread {
    return {
      threadId: isSet(object.threadId) ? globalThis.String(object.threadId) : "",
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      startFrame: isSet(object.startFrame) ? globalThis.Number(object.startFrame) : 0,
      endFrame: isSet(object.endFrame) ? globalThis.Number(object.endFrame) : 0,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => globalThis.String(e)) : [],
      solution: isSet(object.solution) ? VideoRenderingThread_Solution.fromJSON(object.solution) : undefined,
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => VideoRenderingThread_Validation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoRenderingThread): unknown {
    const obj: any = {};
    if (message.threadId !== "") {
      obj.threadId = message.threadId;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.startFrame !== 0) {
      obj.startFrame = Math.round(message.startFrame);
    }
    if (message.endFrame !== 0) {
      obj.endFrame = Math.round(message.endFrame);
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    if (message.workers?.length) {
      obj.workers = message.workers;
    }
    if (message.solution !== undefined) {
      obj.solution = VideoRenderingThread_Solution.toJSON(message.solution);
    }
    if (message.validations?.length) {
      obj.validations = message.validations.map((e) => VideoRenderingThread_Validation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoRenderingThread>, I>>(base?: I): VideoRenderingThread {
    return VideoRenderingThread.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoRenderingThread>, I>>(object: I): VideoRenderingThread {
    const message = createBaseVideoRenderingThread();
    message.threadId = object.threadId ?? "";
    message.taskId = object.taskId ?? "";
    message.startFrame = object.startFrame ?? 0;
    message.endFrame = object.endFrame ?? 0;
    message.completed = object.completed ?? false;
    message.workers = object.workers?.map((e) => e) || [];
    message.solution = (object.solution !== undefined && object.solution !== null)
      ? VideoRenderingThread_Solution.fromPartial(object.solution)
      : undefined;
    message.validations = object.validations?.map((e) => VideoRenderingThread_Validation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoRenderingThread_Solution(): VideoRenderingThread_Solution {
  return { proposedBy: "", hashes: [], files: "" };
}

export const VideoRenderingThread_Solution: MessageFns<VideoRenderingThread_Solution> = {
  encode(message: VideoRenderingThread_Solution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proposedBy !== "") {
      writer.uint32(10).string(message.proposedBy);
    }
    for (const v of message.hashes) {
      writer.uint32(18).string(v!);
    }
    if (message.files !== "") {
      writer.uint32(26).string(message.files);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoRenderingThread_Solution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoRenderingThread_Solution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposedBy = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hashes.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.files = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoRenderingThread_Solution {
    return {
      proposedBy: isSet(object.proposedBy) ? globalThis.String(object.proposedBy) : "",
      hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => globalThis.String(e)) : [],
      files: isSet(object.files) ? globalThis.String(object.files) : "",
    };
  },

  toJSON(message: VideoRenderingThread_Solution): unknown {
    const obj: any = {};
    if (message.proposedBy !== "") {
      obj.proposedBy = message.proposedBy;
    }
    if (message.hashes?.length) {
      obj.hashes = message.hashes;
    }
    if (message.files !== "") {
      obj.files = message.files;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoRenderingThread_Solution>, I>>(base?: I): VideoRenderingThread_Solution {
    return VideoRenderingThread_Solution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoRenderingThread_Solution>, I>>(
    object: I,
  ): VideoRenderingThread_Solution {
    const message = createBaseVideoRenderingThread_Solution();
    message.proposedBy = object.proposedBy ?? "";
    message.hashes = object.hashes?.map((e) => e) || [];
    message.files = object.files ?? "";
    return message;
  },
};

function createBaseVideoRenderingThread_Validation(): VideoRenderingThread_Validation {
  return { validator: "", amountFiles: Long.UZERO, valid: false, isReverse: false };
}

export const VideoRenderingThread_Validation: MessageFns<VideoRenderingThread_Validation> = {
  encode(message: VideoRenderingThread_Validation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (!message.amountFiles.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.amountFiles.toString());
    }
    if (message.valid !== false) {
      writer.uint32(24).bool(message.valid);
    }
    if (message.isReverse !== false) {
      writer.uint32(32).bool(message.isReverse);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoRenderingThread_Validation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoRenderingThread_Validation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amountFiles = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isReverse = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoRenderingThread_Validation {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      amountFiles: isSet(object.amountFiles) ? Long.fromValue(object.amountFiles) : Long.UZERO,
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      isReverse: isSet(object.isReverse) ? globalThis.Boolean(object.isReverse) : false,
    };
  },

  toJSON(message: VideoRenderingThread_Validation): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (!message.amountFiles.equals(Long.UZERO)) {
      obj.amountFiles = (message.amountFiles || Long.UZERO).toString();
    }
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.isReverse !== false) {
      obj.isReverse = message.isReverse;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoRenderingThread_Validation>, I>>(base?: I): VideoRenderingThread_Validation {
    return VideoRenderingThread_Validation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoRenderingThread_Validation>, I>>(
    object: I,
  ): VideoRenderingThread_Validation {
    const message = createBaseVideoRenderingThread_Validation();
    message.validator = object.validator ?? "";
    message.amountFiles = (object.amountFiles !== undefined && object.amountFiles !== null)
      ? Long.fromValue(object.amountFiles)
      : Long.UZERO;
    message.valid = object.valid ?? false;
    message.isReverse = object.isReverse ?? false;
    return message;
  },
};

function createBaseVideoRenderingTaskInfo(): VideoRenderingTaskInfo {
  return { nextId: Long.UZERO };
}

export const VideoRenderingTaskInfo: MessageFns<VideoRenderingTaskInfo> = {
  encode(message: VideoRenderingTaskInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.nextId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.nextId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoRenderingTaskInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoRenderingTaskInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nextId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoRenderingTaskInfo {
    return { nextId: isSet(object.nextId) ? Long.fromValue(object.nextId) : Long.UZERO };
  },

  toJSON(message: VideoRenderingTaskInfo): unknown {
    const obj: any = {};
    if (!message.nextId.equals(Long.UZERO)) {
      obj.nextId = (message.nextId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoRenderingTaskInfo>, I>>(base?: I): VideoRenderingTaskInfo {
    return VideoRenderingTaskInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoRenderingTaskInfo>, I>>(object: I): VideoRenderingTaskInfo {
    const message = createBaseVideoRenderingTaskInfo();
    message.nextId = (object.nextId !== undefined && object.nextId !== null)
      ? Long.fromValue(object.nextId)
      : Long.UZERO;
    return message;
  },
};

function createBaseIndexedVideoRenderingTask(): IndexedVideoRenderingTask {
  return { index: "", videoRenderingTask: undefined };
}

export const IndexedVideoRenderingTask: MessageFns<IndexedVideoRenderingTask> = {
  encode(message: IndexedVideoRenderingTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== "") {
      writer.uint32(10).string(message.index);
    }
    if (message.videoRenderingTask !== undefined) {
      VideoRenderingTask.encode(message.videoRenderingTask, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexedVideoRenderingTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexedVideoRenderingTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.index = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.videoRenderingTask = VideoRenderingTask.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexedVideoRenderingTask {
    return {
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      videoRenderingTask: isSet(object.videoRenderingTask)
        ? VideoRenderingTask.fromJSON(object.videoRenderingTask)
        : undefined,
    };
  },

  toJSON(message: IndexedVideoRenderingTask): unknown {
    const obj: any = {};
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.videoRenderingTask !== undefined) {
      obj.videoRenderingTask = VideoRenderingTask.toJSON(message.videoRenderingTask);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IndexedVideoRenderingTask>, I>>(base?: I): IndexedVideoRenderingTask {
    return IndexedVideoRenderingTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IndexedVideoRenderingTask>, I>>(object: I): IndexedVideoRenderingTask {
    const message = createBaseIndexedVideoRenderingTask();
    message.index = object.index ?? "";
    message.videoRenderingTask = (object.videoRenderingTask !== undefined && object.videoRenderingTask !== null)
      ? VideoRenderingTask.fromPartial(object.videoRenderingTask)
      : undefined;
    return message;
  },
};

function createBaseVideoRenderingLogs(): VideoRenderingLogs {
  return { threadId: "", logs: [] };
}

export const VideoRenderingLogs: MessageFns<VideoRenderingLogs> = {
  encode(message: VideoRenderingLogs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threadId !== "") {
      writer.uint32(10).string(message.threadId);
    }
    for (const v of message.logs) {
      VideoRenderingLogs_VideoRenderingLog.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoRenderingLogs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoRenderingLogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.threadId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.logs.push(VideoRenderingLogs_VideoRenderingLog.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoRenderingLogs {
    return {
      threadId: isSet(object.threadId) ? globalThis.String(object.threadId) : "",
      logs: globalThis.Array.isArray(object?.logs)
        ? object.logs.map((e: any) => VideoRenderingLogs_VideoRenderingLog.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoRenderingLogs): unknown {
    const obj: any = {};
    if (message.threadId !== "") {
      obj.threadId = message.threadId;
    }
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => VideoRenderingLogs_VideoRenderingLog.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoRenderingLogs>, I>>(base?: I): VideoRenderingLogs {
    return VideoRenderingLogs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoRenderingLogs>, I>>(object: I): VideoRenderingLogs {
    const message = createBaseVideoRenderingLogs();
    message.threadId = object.threadId ?? "";
    message.logs = object.logs?.map((e) => VideoRenderingLogs_VideoRenderingLog.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoRenderingLogs_VideoRenderingLog(): VideoRenderingLogs_VideoRenderingLog {
  return { log: "", timestamp: Long.ZERO, severity: 0 };
}

export const VideoRenderingLogs_VideoRenderingLog: MessageFns<VideoRenderingLogs_VideoRenderingLog> = {
  encode(message: VideoRenderingLogs_VideoRenderingLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.log !== "") {
      writer.uint32(18).string(message.log);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timestamp.toString());
    }
    if (message.severity !== 0) {
      writer.uint32(32).int32(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoRenderingLogs_VideoRenderingLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoRenderingLogs_VideoRenderingLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.log = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoRenderingLogs_VideoRenderingLog {
    return {
      log: isSet(object.log) ? globalThis.String(object.log) : "",
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      severity: isSet(object.severity) ? videoRenderingLogs_VideoRenderingLog_SEVERITYFromJSON(object.severity) : 0,
    };
  },

  toJSON(message: VideoRenderingLogs_VideoRenderingLog): unknown {
    const obj: any = {};
    if (message.log !== "") {
      obj.log = message.log;
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (message.severity !== 0) {
      obj.severity = videoRenderingLogs_VideoRenderingLog_SEVERITYToJSON(message.severity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoRenderingLogs_VideoRenderingLog>, I>>(
    base?: I,
  ): VideoRenderingLogs_VideoRenderingLog {
    return VideoRenderingLogs_VideoRenderingLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoRenderingLogs_VideoRenderingLog>, I>>(
    object: I,
  ): VideoRenderingLogs_VideoRenderingLog {
    const message = createBaseVideoRenderingLogs_VideoRenderingLog();
    message.log = object.log ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.severity = object.severity ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
